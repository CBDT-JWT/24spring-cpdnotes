# lec3
**对象数组的构建**
`类名 对象名[长度] = {构造函数(实参列表1),...}`

存在全缺省参数/默认构造函数时可以不显式调用构造函数

对象首地址->对象指针

对象数据成员首地址->指向数据成员的指针

对象成员函数首地址->指向成员函数的指针

可以用对象指针建立动态对象数组.(注意有没有默认构造函数可以用)

**static**的构造和析构

深复制vs.浅复制:字符串/指针指向对象被复制vs.只抄了地址

`this`指针:自引用指针,指向成员正在操作的地址

`x` <-> `this->x`
## 数据的保护与共享
|知识点|定义形式|性质|
|---|---|---|
|常量|`const int`|可初始化,无法被修改|
|常对象|`const myclass obj`| |
|对象中的常成员| 类内数据加上`const`修饰符 | 对象初始化后无法修改|
|常指针| `int* const ptr` | 赋值后无法修改 |
|指向常对象的指针| ` const myclass* ptr` | 可以指向常对象(普通指针不能指向常对象) |
|指向常对象的常指针|`const myclass* const ptr`| 兼具上述二者性质 |

**对象的常引用**
- 函数参数采用常量避免被函数修改,但只能访问常成员
- 常成员函数:不能修改数据成员
- 常对象不能调用普通成员函数(保护机制)
- 想在常成员函数中修改数据,需要在数据前加`mutable`修饰符

**数据共享**:静态数据与静态函数
- 初始化:只能在主程序外初始化,不能采用构造函数(不属于某个对象,而是属于一个类!)
- 引用方式:`obj.num`或者`myclass::num`
- 不依附于任何对象,可以通过类或对象访问
- 只是存储类型不同,访问属性没有改变!
- 意义:实现**对象间的**数据通信

常静态数据`const static`

**静态函数**
- `static int func(int foo)`
- 同样不属于某个对象,没有`this`指针,无法访问本类中非静态成员.(报错`对非静态成员的非法引用`)

## 友元

**友元机制**
- 友元函数
- 友元类

**友元函数**
- 白名单制
-`friend int foo(int bar)`

可以声明友元类

**类的组合**:类的数据成员是另一个类的对象
- 先顺序执行内嵌对象的构造函数,再执行本对象的构造函数.
