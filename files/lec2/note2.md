# 第二讲
**类与对象**
## 类和对象
对象(object):构成一个系统的基本单位,具有**属性**(attribute)和**行为**(behavior).

在C++中,**类**(class)由*数据*和*函数*组成

类可以*继承和派生*,并引出了*访问权限控制和调整*,*保护成员*等一系列问题.

类对数据和函数的*访问属性*进行了限定.

>类不是类型,是一种封装
类是对象的抽象,对象是类的实例

类 --> 本科生
对象 --> 张三
*对象占用内存空间,而类不占用*
**成员访问限定符**
- `private`的数据和函数只能被本类的成员函数和数据所调用,其他数据和函数(**包括主函数**)不能访问.一个`class`里的多个对象`A`和`B`,则`B`可以访问`A`的`private`成员
- `public`的数据和函数既可以被本类的成员函数调用
- `protected`:后面会讲

良好习惯:先写`public`,再写`private`,每种限定符**只出现一次**

**对象定义的方式**
- 先声明类,再定义对象
```c++
/* 声明Tdate类 */
class Tdate{
    public:
    //public
    private:
    //private
};
/* 定义对象 */
int main(){
    Tdate today,tomorrow;
}
```
- 类声明和定义同时完成
``` C++
class Tdate{
    public:
    //public
    private:
    //private
}today,tomorrow;
```
- 直接定义对象,忽略类名*很少使用*
``` C++
class{
    public:
    //public
    private:
    //private
}today,tomorrow;
```

**对象的引用**
- 通过**对象名**引用对象中的成员.一般形式为`object.member`或`object.func()`
- 通过**指向对象的指针**引用对象的成员.一般形式为`ptr->member`
- 通过**对象的引用变量**引用对象的成员.

**函数的重载**
一种数据抽象,允许函数同名,对函数返回值类型没有要求,但是要求**函数的参数类型和个数不能完全相同.**
- 函数参数个数不同,由**实参个数**决定
- 函数参数个数相同,由**实参类型**决定
- 找不到就报错

*实参类型非常关键*:`f(1)`和`f(0.1)`不是同一个函数!


## 成员函数
在类中声明的函数成为该类的**成员函数**
- 类成员函数同样具有*返回值*,*函数类型*和*函数参数*
- 类成员函数可以指定为`private`/`public`
    - 类的对外接口一般作为`public`

**成员函数的声明与定义**
- 类体中直接定义函数使不需要类名;类外定义必须在函数名前面加上**类名**和`::`
    - `::`作为*类作用域符*
- 同一类内部的成员国函数同样可以进行重载
- 不同类的成员函数之间互不相干,不是重载函数.
- 成员函数也可以`inline`

## 构造函数和析构函数
- **构造函数**:负责对象的初始化工作
    - 比如给`private`成员赋初值
- **析构函数**:负责释放对象前的准备工作

构造函数和析构函数不在程序中显式直接调用,而是在对象**创建和撤销**时隐式自动调用.
```c++
    class Myclass{
        public:
            Myclass(int i){
                cout<<"constructor called"<<endl;
            }
    }
    Myclass obj(10);
```
析构与构造顺序完全相反,一一对应.

**C++提供了构造函数和析构函数**
- 与类同名的成员函数:构造函数
- 与类同名的成员函数:析构函数

**调用时机**
- 函数中定义了对象时就会调用**构造函数**,函数执行结束时调用**析构函数**
- 全局对象在程序的流程离开其作用于时候执行析构函数
- `static`的对象在函数结束调用时候并不会执行析构函数
- `static`比全局更早析构
- 用`new`建立对象时候调用析构函数,对应`delete`时候调用析构函数

**成员函数也可以有缺省值**

**复制构造函数**:一种特殊的构造函数,形参只有一个且是本类对象的引用
- 作用:使用一个已经存在的对象,构造并初始化同类的一个新对象.
```c++
class Myclass{
    public:
        Myclass(int i){
            member = i;
        }
        Myclass(Myclass &b){
            member = b.member;
        }
    private:
        int member;
}

```
- 调用方法:`Myclass obj2(obj1);`或`Myclass obj2 = obj1;`.如果没有定义复制构造函数就这么写,系统会自动生成一个赋值函数,但如果涉及指针可能出现问题.

- 调用时机:
    1. 用对象赋初值
    1. 往函数里传对象(形参)*本质是复制了一个对象传进去*,会造成资源浪费
    1. 函数返回对象

- 可以通过传引用来避免调用复制构造函数,提高运行效率.

**对象的赋值**
- 同类对象中可以用`=`直接赋值:`obj1=obj2`
- **赋值过程不调用复制构造函数**,因为不是产生新对象的过程.

注意:存在动态分配内存的时候,直接赋值或采用自动生成的复制构造函数会产生*浅复制*问题.
**需要手动写复制构造函数**:对于指针/数组型成员需要`new`新的内存空间单独复制