# 运算符重载
## 链表类
每个表项有结点构成,每个阶段包含数据和指针
```
[HEAD]->[数据1:*next-]->[数据2:*next-]->...

listnode
 ______       ______  
| data |  /->| data |   /->
|------|/    |------| /   ...
|*next/|     |*next/|
|______|     |______| 
```
## 运算符重载
**重载的含义**
- 重:必须是已有的运算符
- 不改变原有运算符的结合性,操作数个数和优先级
- 实质是函数的重载,通过不同而类型的数据导致不同行为

**无法重载**:`.`,`.*`,`::`,`?:`,`sizeof()`和`typeid()`.

运算符调用规则:转化为对运算符函数的调用.

**书写方式**
- ` <函数类型> operator <运算符> (<形参>) {...} `
- 重载为成员函数时,形参个数是运算符操作数个数-1(后置`++`,`--`除外)
    - 类声明中写`<函数类型> operator <运算符> (<形参>);`
    - 通过`this`指针可以自由访问苯类的数据参数
    - 要求运算表达式是第一个参数是同类对象(即运算符左侧的操作数)
- 重载为友元函数时,形参个数是运算符操作数格式(后置`++`,`--`除外)
    - 类声明中写`friend <函数类型> operator <运算符> (<形参>);`

```C++
class pwr{
    private:
        int num;
    public:
        pwr(int n){
            num = n;
        }
        friend int operator ^ (pwr a,pwr b)
};
```
### 二目运算符

**重载为成员函数**
- 运算表达式:`<操作数1> <运算符> <操作数2>`
- 若`<操作数1>`为A类对象,则`<运算符>`应重载为A的成员函数,等价于`<操作数1>.<运算符>(<操作数2>)`
- 声明形式
    - 类声明内 `<类名> operator<运算符>(<类型名><形参变量名>);`
    - 类外写 `<类名>::<类名>operator<运算符>(<类型><形参变量名>){...}`

参数采用引用可以提高运行效率;采用常引用避免参数被修改.

**重载为友元函数**
- 运算表达式:`<操作数1> <运算符> <操作数2>`
- `<运算符>`应重载为函数,等价于`<运算符>(<操作数1>,<操作数2>)`
- 声明形式
    - 类声明内 `friend <类名> operator<运算符>(<类型名1><形参变量名1>,<类型名2><形参变量名2>);`
    - 类外写 `<类名>::<类名>operator<运算符>(<类型1><形参变量名1><类型2><形参变量名2>){...}`

```C++
    friend complex operator +(const complex &a, const complex &b);
/*...*/
    complex::complex operator +(const complex &a,const complex &b){
        return complex(a.r+b.r,a.i+b.i);
    }
```
### 单目运算符

**调用规则**:`<操作数><运算符>`(后置)或`<运算符><操作数>`(前置)
- 前置没有形参,`<运算符><操作数>`等价于调用`<操作数>.<运算符>()`函数
- 后置有形参,`<操作数><运算符>`等价于 `<操作数>.运算符>(0)`

**注意**:   一元重载操作符若不使用引用,则无法改变成员的值

```C++
    Clock::void operator -- (){
        this -> S --;
        this -> M += S<0;
        this -> H += M<0;
        this -> S += 60*(S<0);
        this -> M += 60*(M<0);
        this -> H += 24*(H<0);
        return ;
    }
    Clock::void operator -- (Clock&c, int){//已经声明为友元函数
        c. S --;
        c. M += S<0;
        c. H += M<0;
        c. S += 60*(S<0);
        c. M += 60*(M<0);
        c. H += 24*(H<0);
    }
```